#include <iostream>#include <vector>#include <string>#include <stdio.h>#include <stdlib.h>#include <cstring>#include <stdint.h>// web#include <cgicc/CgiDefs.h>#include <cgicc/Cgicc.h>#include <cgicc/HTTPHTMLHeader.h>#include <cgicc/HTMLClasses.h>#include "cJSON.h"// "cJSON.h" included as the last// driver#include <wiringPi.h>#include <wiringPiSPI.h>#include "MFRC522.H"#include <time.h>#include <sys/types.h>#include <unistd.h>using namespace std;using namespace cgicc;/**prepare driver*///M1卡的某一块写为如下格式，则该块为钱包，可接收扣款和充值命令//4字节金额（低字节在前）＋4字节金额取反＋4字节金额＋1字节块地址＋1字节块地址取反＋1字节块地址＋1字节块地址取反unsigned char data1[16] = {0x12,0x34,0x56,0x78,0xED,0xCB,0xA9,0x87,0x12,0x34,0x56,0x78,0x01,0xFE,0x01,0xFE};unsigned char DefaultKey[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}; 	//默认密钥unsigned char g_ucTempbuf[20];		//接口缓存int check(void) {	/* driver start*/	int res = wiringPiSetup();					    //wiringPi初始化    if (res != MI_OK){//        cout << status << endl;    }//	cout << res << endl;	wiringPiSPISetup(channel, speed);		//设置SPI通道 0，速率 1000000//	printf ("Raspberry Pi RFID\n") ;	unsigned char status, i, j, any_error;	delay(500);	PcdReset();		//RC522复位	PcdAntennaOff();	//关闭天线	delay(10);		//每次启动或关闭天线之间应至少有1ms的间隔	PcdAntennaOn();  	//开启天线    //==============================================================    // prepare response json    cJSON *root,*fmt;    // 创建一个cJSON对象    root=cJSON_CreateObject();//    cJSON_AddItemToObject(root, "name", cJSON_CreateString("wxc"));//    cJSON_AddItemToObject(root, "format", fmt=cJSON_CreateObject());//    cJSON_AddStringToObject(fmt,"type",		"rect");//    cJSON_AddNumberToObject(fmt,"width",		1920);//    cJSON_AddNumberToObject(fmt,"height",		1080);    Cgicc formData;    /*Get Request json.msg*/    form_iterator fi = formData.getElement("msg");    if( !fi->isEmpty() && fi != (*formData).end()) {    //	      cout << "Text Content: " << **fi << endl;        cJSON_AddItemToObject(root, "msg", cJSON_CreateString((**fi).c_str()));    }else{    //	      cout << "No text entered" << endl;        cJSON_AddItemToObject(root, "msg", cJSON_CreateString("no message"));    }    /*Get Request json.myjsn*/    fi = formData.getElement("myjsn");    if( !fi->isEmpty() && fi != (*formData).end()) {//         cout << "Text Content: " << **fi << endl;        char *out;        cJSON *json;        char str[1024];        int len = (**fi).length();        (**fi).copy(str, len,0);        *(str + len)='\0';//        cout << str << endl;        json=cJSON_Parse(str);        if (!json) {//            printf("Error before: [%s]\n",cJSON_GetErrorPtr());        }else{            out=cJSON_Print(json);        //			child = cJSON_GetObjectItem(json, "name");        //			out=cJSON_Print(child);            cJSON_Delete(json);        //		printf("***************:%s\n",out);        //		printf("\n");//            fprintf(stdout,"get json is %s", out);//            fprintf(stdout,"\n");            free(out);        }    }else{//     cout << "No text entered" << endl;    }    /*Get Request json.total*/    double total = 0.0;    fi = formData.getElement("total");    if( !fi->isEmpty() && fi != (*formData).end()) {    //	      cout << "Text Content: " << **fi << endl;//        cJSON_AddItemToObject(root, "total", cJSON_CreateString((**fi).c_str()));        total = atof((**fi).c_str());        cJSON_AddNumberToObject(root,"total", total);    }else{    //	      cout << "No text entered" << endl;        cJSON_AddItemToObject(root, "total", cJSON_CreateString("no message"));//        printf("%s\n", (**fi).c_str());    }//	clock_t start_t, end_t;//	double total_t;//	start_t = clock();	int read_seconds = 115; //30* 4*250	while(read_seconds > 0)	{	    any_error = 0;		status = PcdRequest(PICC_REQALL, g_ucTempbuf);		//寻卡		any_error |= status;		if (status != MI_OK) {//		    cJSON *err;//            cJSON_AddItemToObject(root, "PcdRequest", err=cJSON_CreateObject());//            cJSON_AddNumberToObject(err,"status", status);            delay(250);            --read_seconds;//            printf("waiting\n");            continue;            // 如果没有找到卡则不进行下方操作		}//		printf("\ncard type:");//		switch(g_ucTempbuf[0])//		{//			case 0x02:{//                printf("Mifare_One(S70)\n");//                break;//			}//			case 0x04:{//			    printf("Mifare_One(S50)\n");//			    break;//			}//			case 0x08:{//			    printf("Mifare_Pro(X)\n");//			    break;//			}//			case 0x44:{//			    if(g_ucTempbuf[1] == 0x00){//			        printf("Mifare_UltraLight\n");//			        break;//			    }else if(g_ucTempbuf[1] == 0x03) {//			        printf("Mifare_DESFire\n");//			        break;//			    }//			}//		}		cJSON_AddNumberToObject(root,"card_type",g_ucTempbuf[0]);		status = PcdAnticoll(g_ucTempbuf);			//防冲撞		any_error |= status;		if (status != MI_OK) {		    cJSON *err;            cJSON_AddItemToObject(root, "PcdAnticoll", err=cJSON_CreateObject());            cJSON_AddNumberToObject(err,"status", status);//            printf("PcdAnticoll\n");		}//		printf("\ncard SN:");        int sn[5] = {0};		for(i=0;i<4;i++)		{            sn[i] = g_ucTempbuf[i];//			if(g_ucTempbuf[i] < 0x10){//			    printf("0%X",g_ucTempbuf[i]);//			}//			else{//			    printf("%X",g_ucTempbuf[i]);//			}		}		cJSON_AddItemToObject(root, "card_SN", cJSON_CreateIntArray(sn, 5));//		printf("\n");		status = PcdSelect(g_ucTempbuf);			//选定卡片		any_error |= status;		if (status != MI_OK) {		    cJSON *err;            cJSON_AddItemToObject(root, "PcdSelect", err=cJSON_CreateObject());            cJSON_AddNumberToObject(err,"status", status);//            printf("PcdSelect\n");		}		status = PcdAuthState(PICC_AUTHENT1A, 1, DefaultKey, g_ucTempbuf);	//验证卡片密码		any_error |= status;		if (status != MI_OK) {		    cJSON *err;            cJSON_AddItemToObject(root, "PcdAuthState", err=cJSON_CreateObject());            cJSON_AddNumberToObject(err,"status", status);//            printf("PcdAuthState\n");		}        for(i=0;i<4;i++)        {            status = PcdRead(i, g_ucTempbuf);				//读块            any_error |= status;            if (status != MI_OK) {                cJSON *err;                cJSON_AddItemToObject(root, "PcdRead", err=cJSON_CreateObject());                cJSON_AddNumberToObject(err,"status", status);            }//            printf("\nread block %d:", i);//            int j;//            for(j=0;j<16;j++)//            {//                if(g_ucTempbuf[j] < 0x10)    printf("0%X",g_ucTempbuf[j]);//                else    printf("%X",g_ucTempbuf[j]);//            }            uint32_t val1,val2,nVal1 = 0;            uint32_t tail = 0;            memcpy((void*)&val1, g_ucTempbuf, 4);            memcpy((void*)&nVal1, g_ucTempbuf+4, 4);            memcpy((void*)&val2, g_ucTempbuf+8, 4);            memcpy((void*)&tail, g_ucTempbuf+12, 4);            double card_balance = 0;            memcpy((void*)&card_balance, g_ucTempbuf, 8);            if(i==1) {//                cJSON_AddNumberToObject(root, "balance", val1);                if(card_balance < total) {                    cJSON_AddNumberToObject(root, "insufficient", card_balance-total);                }else {                    card_balance -= total;                    memcpy(g_ucTempbuf, &card_balance, 8);                    status = PcdWrite(1, g_ucTempbuf);						//写块1                    any_error |= status;                    if (status != MI_OK)                    {                        cJSON *err;                        cJSON_AddItemToObject(root, "PcdWrite", err=cJSON_CreateObject());                        cJSON_AddNumberToObject(err,"status", status);                    }                }                cJSON_AddNumberToObject(root, "balance", card_balance);            }//            printf("%x, %x, %x, %x\n", val1, nVal1, val2, tail);//            if(i==1) {//                cJSON_AddNumberToObject(root, "balance", val1);////                val1 -= 1;//                memcpy(g_ucTempbuf, &val1, 4);//                status = PcdWrite(1, g_ucTempbuf);						//写块1//                any_error |= status;//                if (status != MI_OK)//                {//                    cJSON *err;//                    cJSON_AddItemToObject(root, "PcdWrite", err=cJSON_CreateObject());//                    cJSON_AddNumberToObject(err,"status", status);//                }//            }        }//		status = PcdWrite(1, data1);						//写块1//		if (status != MI_OK)//		{//			/*continue*/ cout << status << endl;//		}//		status = PcdBakValue(1, 2);						//块备份1 --> 2//		if (status != MI_OK)//		{//			/*continue*/ cout << status << endl;//		}//		for(i=0;i<4;i++)//		{//			status = PcdRead(i, g_ucTempbuf);				//读块////            if (status != MI_OK) {//                cJSON *err;//                cJSON_AddItemToObject(root, "PcdAuthState", err=cJSON_CreateObject());//                cJSON_AddNumberToObject(err,"status", status);//            }//			printf("\nread block %d:", i);//			int j;//			for(j=0;j<16;j++)//			{//				if(g_ucTempbuf[j] < 0x10)    printf("0%X",g_ucTempbuf[j]);//				else    printf("%X",g_ucTempbuf[j]);//			}//		}//		printf("\n");		PcdHalt();			//卡片进入休眠状态//		end_t = clock();//		total_t = (double)(end_t - start_t) / CLOCKS_PER_SEC;//		printf("now : %f\n", total_t);//		if(total_t>5.0) {//			break;//		}//		printf("any_error = %x\n", any_error);        if(!any_error) {    // 正确读卡则退出循环不再刷卡            break;        }//		delay(1000);	// 注意在delay的时候clock不计时        // 把上面的延时去掉，就能一次读到了（？//		--read_seconds;	}    char *out;    out=cJSON_Print(root);	cJSON_Delete(root);	printf("%s\n",out);	free(out);	/* Print to text, Delete the cJSON, print it, release the string. */}int main (){//	uid_t uid ,euid;//	uid = getuid();//	euid = geteuid();//	if(setreuid(euid, uid))  //交换这两个id以获取root权限//		perror("setreuid");	cout << "Content-type:text/html;charset=utf-8\n\n";	// !REQUIRED!//	clock_t start_t, end_t;//	double total_t;//	start_t = clock();//	while(1){//		end_t = clock();//		total_t = (double)(end_t - start_t) / CLOCKS_PER_SEC;////		printf("now : %f\n", total_t);//		if(total_t>5.0) {//			break;//		}//	}	int res = check();//	if (res != 0){//		cout << res << endl;//	}   return 0;}